---
layout: post
title:  "Frequently Asked Questions"
kicker: "Basics"
summary: "This post answers frequently asked questions about the Rust programming language. It neither serves as a comprehensive manual for the language nor as a tool for teaching the language."
image: assets/images/posts-cover-images/rust-faqs.jpg
image-credits: "AI-generated image by <a href='https://www.freepik.com/' target='_blank'>freepik</a>."
imageshadow: true
toc: true
author: senthil
date: 2023-11-23 00:00:00 +0530
# last_modified_at: 2023-11-18
tags: [ "basics", "faqs" ]
categories: faqs
featured: false
hidden: true
---

# Compilation

## What options do we have to improve the "liking stage" during Rust's compilation?

A considerable amount of time appears to be spent to the **linkage phase**[^1] of the compilation. Despite the fact that the default linker performs reasonably well, better alternatives exist, depending on the operating system we have:

- **Windows**: [LLD](https://lld.llvm.org/windows_support.html#downloading-lld){:target="_blank"}
- **Linux**: [LLVM](https://releases.llvm.org/download.html){:target="_blank"}
- **macos**: [zld](https://github.com/michaeleisel/zld/releases/tag/1.3.9.1){:target="_blank"}

---

# Data types

## What are the differences between the two different string types?

In Rust, there are two types of strings: 
 - `String` 
   - `String` is a heap-allocated, growable, mutable string.
   - 
 - `&str`
   - `&str` is a string reference slice, aka **string slice**.
   - 


## How can I convert a String or to a slice, &str?

todo

---

# Collections

todo

---

# Ownership, borrowing, and lifetimes

todo

---

# Concurrency

## How does a kernel-level thread differ from a user-level thread?

**Kernel-level threads**, aka native threads, are managed by the operating system kernel. The operating system is responsible for scheduling and context switching. It's heavier than user-level threads in terms of overhead. It's better suited for scenarios requiring parallelism and direct interaction with system services. 

**Disadvantages**

- Relatively limited number we can create!

**User-level threads**, also known as lightweight threads or green threads, are managed entirely by a user-level thread library or runtime. The operating system kernel is unaware of these threads. It's lightweight and have lower overhead compared to kernel-level threads. Scheduling and context switching are performed by the user-level thread library or runtime. It's efficient for scenarios where a large number of threads need to be managed. Since it's lighter weight, we can create many more green threads.

**Disadvantages**

- Stack growth can cause issues!

---

# Error handling

## What is panic in Rust?

A **panic** is the term refers to the occurrence of a _runtime error_ that causes the program to terminate abruptly. It indicates that a program has reached a state where further execution is not possible or safe. 

When a panic occurs, the runtime system begins to unwind the stack of the thread where the panic happened. Unwinding involves the cleanup of stacks and resources, such as freeing memory and running destructors for local variables, in reverse order of their creation.

---

# Design Patterns

todo

---

# Generics

todo

---

# Macros

## What is a configuration conditional check?

A configuration conditional check is a conditional check based on configuration that typically refers to one of the following conditional compilation directives:

- the cfg attribute: `#[cfg(...)]` in attribute position
- the cfg! macro: `cfg!(...)` in boolean expressions

This directive allows us to conditionally include or exclude blocks of code based on the compilation configuration.

**Syntax**: `#[cfg(condition)]`

**Example**:

```rust
// cfg attribute style
#[cfg(target_os = "windows")]
fn windows_specific_function() {
    // Windows-specific code
}

#[cfg(target_os = "linux")]
fn linux_specific_function() {
    // Linux-specific code
}

// cfg! macro style
if cfg!(target_os = "linux") {
    println!("Yes. It's definitely linux!");
} else {
    println!("Yes. It's definitely *not* linux!");
}
```

---

# Testing

## What is fuzz testing or fuzzing?

Fuzzing, or fuzz testing, is a software testing technique that involves providing invalid, unexpected, malformed, or random data as inputs to a computer program to reveal vulnerabilities, bugs, or unexpected behavior in the target software. This helps identify areas of the code that may be susceptible to security vulnerabilities or other issues.

---

[^1]: **Linking** is the process of combining one or more object files generated by a compiler or an assembler and combining them into a single executable file, library file, or another object file.